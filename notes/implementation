# Clojure vs ClojureScript

Here's a tricky question. Right now, the implementation of the forms API has started to move towards a convention of annotating the Hiccup elements with platform type information like:
```clojure
{:data-java-class "clojure.lang.Symbol"
 :data-clojure-symbol "my/sym"}
```

This opens up a can of worms because this type information will obviously not be consistent cross platform:
```clojure
{:data-js-class "cljs.core/Symbol"
 :data-cljs-symbol "my/sym"}
```

However, just using reader conditionals to dispatch to the appropriate platform defaults is too quick; Clojure (JVM) code might be parsed by `rewrite-clj` running in the browser, so it would not make sense to assign JS types to elements derived from JVM Clojure source code. The inverse might also be true: ClojureScript code might be parsed on the JVM. 

So part of the necessary complexity here is to convey to `adorn` whether the given form is Clojure or ClojureScript. Once `adorn` has this information it can populate the above metadata appropriately. When the ability to dynamically inspect types is available (e.g. reading cljs code from cljs, clj code from clj), use it. When it's not (e.g. reading cljs code from clj, clj code from cljs), default to static lookup and use a generic platform type (e.g. [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object), [`java.lang.Object`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html)) placeholder value for unknown types. This implies that static lookup needs to be implemented for all primitive (e.g. non-Object) types for both clj and cljs.

The multimethod-based API may allow users to extend `adorn`'s methods to arbitrary CLJS and CLJ types.

